======================== USER ==============================

HOW TO USE /api/v2/users – FRONT-END TUTORIAL (TXT VERSION)

============================================================
BASE

Base URL: /api/v2/users
Headers padrão: Content-Type: application/json
CORS: liberado para qualquer origem
Observação: Não há autenticação neste controller. Se o back adicionar no futuro, incluir Authorization: Bearer <token>.

============================================================
DTOS (FORMATOS DOS DADOS)

LoginRequestDTO:
email: string
password: string

UserRequestDTO:
email: string
password: string
username: string
cpfCnpj: string

LoginResponseDTO:
ok: boolean
message: string
Valores comuns: "Autenticado com sucesso" ou "Credenciais inválidas"

UserResponseDTO:
id: number
email: string
username: string

ChangePasswordDTO:
oldPassword: string
newPassword: string

UpdateUsernameDTO:
username: string

ConsumoResponseDTO:
id: number
userId: number | null
productId: number | null
dataConsumo: string (yyyy-MM-dd)
pesquisaRespondida: boolean
pesquisaId: number | null

ApiError:
code: "NOT_FOUND" | "UNAUTHORIZED" | "BAD_REQUEST" | "VALIDATION_ERROR" | "CONSTRAINT_VIOLATION"
message: string

============================================================
ENDPOINTS E EXEMPLOS

LOGIN

POST /api/v2/users/login

Request (JSON):
{
"email": "user@exemplo.com
",
"password": "SenhaForte123"
}

Response 200 (sucesso):
{
"ok": true,
"message": "Autenticado com sucesso"
}

Response 200 (falha de credenciais):
{
"ok": false,
"message": "Credenciais inválidas"
}

Exemplo (fetch, JavaScript):
const res = await fetch("/api/v2/users/login", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ email, password })
});
const data = await res.json();
if (data.ok) {
// fluxo logado
} else {
// exibir data.message
}

CRIAR USUÁRIO

POST /api/v2/users

Request (JSON):
{
"email": "novo@exemplo.com
",
"password": "Senha@123",
"username": "novoUser",
"cpfCnpj": "12345678910"
}

Response 201 (Created) + Location header:
{
"id": 42,
"email": "novo@exemplo.com
",
"username": "novoUser"
}

Erros possíveis:

409 CONSTRAINT_VIOLATION (duplicidade unique: email/cpfCnpj/username)

422 VALIDATION_ERROR (campos inválidos)

400 BAD_REQUEST (corpo malformado)

Exemplo (Axios):
import axios from "axios";
const { data } = await axios.post("/api/v2/users", {
email, password, username, cpfCnpj
});
// data.id disponível

LISTAR USUÁRIOS (PAGINAÇÃO E FILTROS)

GET /api/v2/users

Query params:

page (0-based), size, sort (ex.: sort=username,ASC)

Filtros exclusivos (o controller prioriza um):
email=... OU
username=... OU
cpfCnpj=...

Observações:

Se enviar email, os demais filtros são ignorados e o back retorna 0 ou 1 item.

Sem filtro, retorna página completa.

Response 200 (Page<UserResponseDTO>):
{
"content": [
{ "id": 1, "email": "a@a.com
", "username": "a" },
{ "id": 2, "email": "b@b.com
", "username": "b" }
],
"totalElements": 17,
"totalPages": 9,
"size": 2,
"number": 0,
"first": true,
"last": false,
"numberOfElements": 2,
"empty": false
// Demais metadados padrão do Spring podem aparecer
}

Exemplos de URLs:

/api/v2/users?page=0&size=10&sort=username,ASC

/api/v2/users?email=alguem@dominio.com

BUSCAR POR ID

GET /api/v2/users/{id}

Response 200:
{ "id": 42, "email": "novo@exemplo.com
", "username": "novoUser" }

Erro 404:
{ "code": "NOT_FOUND", "message": "Usuario não encontrado" }

LISTAR CONSUMOS DO USUÁRIO

GET /api/v2/users/{id}/consumos

Response 200 (array de ConsumoResponseDTO):
[
{
"id": 11,
"userId": 42,
"productId": 7,
"dataConsumo": "2025-11-01",
"pesquisaRespondida": true,
"pesquisaId": 99
}
]

Erro 404:
{ "code": "NOT_FOUND", "message": "Usuario não encontrado" }

TROCAR SENHA

PATCH /api/v2/users/{id}/password

Request (JSON):
{ "oldPassword": "Senha@123", "newPassword": "NovaSenha@456" }

Response 204 (sem corpo)

Erros possíveis:

401 UNAUTHORIZED, message: "Credenciais invalidas"

404 NOT_FOUND

422 VALIDATION_ERROR

TROCAR USERNAME

PATCH /api/v2/users/{id}/username

Request (JSON):
{ "username": "novoApelido" }

Response 200:
{ "id": 42, "email": "novo@exemplo.com
", "username": "novoApelido" }

Erros possíveis:

404 NOT_FOUND

400 BAD_REQUEST, message: "Username ja existente"

422 VALIDATION_ERROR

REMOVER USUÁRIO POR ID

DELETE /api/v2/users/{id}

Response 204

Erro 404:
{ "code": "NOT_FOUND", "message": "Usuario não encontrado" }

REMOVER POR CHAVE ESPECÍFICA

DELETE /api/v2/users/by-email/{email}
DELETE /api/v2/users/by-username/{username}
DELETE /api/v2/users/by-cpf-cnpj/{cpfCnpj}

Response 204 ou 404 (Usuario não encontrado)

============================================================
PADRÕES DE ERRO (TRATAMENTO NO FRONT)

HTTP 400 – BAD_REQUEST
Quando: Requisição inválida ou regra de negócio falhou
Ação: Mostrar ApiError.message

HTTP 401 – UNAUTHORIZED
Quando: Senha antiga incorreta no change password
Ação: Exibir “Credenciais inválidas”

HTTP 404 – NOT_FOUND
Quando: Usuário não existe
Ação: Exibir “Usuário não encontrado”

HTTP 409 – CONSTRAINT_VIOLATION
Quando: Violação de unique/FK (email/username/cpfCnpj duplicado etc.)
Ação: Exibir “Já existe um registro com esses dados”

HTTP 422 – VALIDATION_ERROR
Quando: Campos faltando/violando validação
Ação: Exibir erros por campo e orientar correção

Dica geral: Sempre ler o corpo e usar ApiError.message para feedback amigável.

============================================================
SNIPPETS PRONTOS
Client fino (Axios):

import axios from "axios";

const http = axios.create({
baseURL: "/api/v2/users",
headers: { "Content-Type": "application/json" }
});

export const UsersApi = {
login: (body) =>
http.post("/login", body).then(r => r.data),

create: (body) =>
http.post("", body).then(r => r.data),

list: (params) =>
http.get("/", { params }).then(r => r.data),

getById: (id) =>
http.get(/${id}).then(r => r.data),

listConsumos: (id) =>
http.get(/${id}/consumos).then(r => r.data),

changePassword: (id, body) =>
http.patch(/${id}/password, body).then(() => {}),

changeUsername: (id, body) =>
http.patch(/${id}/username, body).then(r => r.data),

deleteById: (id) =>
http.delete(/${id}).then(() => {}),

deleteByEmail: (email) =>
http.delete(/by-email/${encodeURIComponent(email)}).then(() => {}),

deleteByUsername: (username) =>
http.delete(/by-username/${encodeURIComponent(username)}).then(() => {}),

deleteByCpfCnpj: (cpfCnpj) =>
http.delete(/by-cpf-cnpj/${encodeURIComponent(cpfCnpj)}).then(() => {})
};

Uso com React Query (exemplos):

Listagem paginada:
const { data, isLoading, error } = useQuery({
queryKey: ["users", page, size, sort],
queryFn: () => UsersApi.list({ page, size, sort })
});

Criar usuário:
const createUser = useMutation({
mutationFn: UsersApi.create,
onSuccess: () => queryClient.invalidateQueries({ queryKey: ["users"] })
});

Trocar username:
const updateUsername = useMutation({
mutationFn: ({ id, username }) =>
UsersApi.changeUsername(id, { username }),
onSuccess: (_data, vars) =>
queryClient.invalidateQueries({ queryKey: ["user", vars.id] })
});

============================================================
CURL PARA TESTES RÁPIDOS

LOGIN:
curl -X POST http://localhost:8080/api/v2/users/login

-H "Content-Type: application/json"
-d "{"email":"user@exemplo.com
","password":"SenhaForte123"}"

CREATE:
curl -X POST http://localhost:8080/api/v2/users

-H "Content-Type: application/json"
-d "{"email":"novo@exemplo.com
","password":"Senha@123","username":"novoUser","cpfCnpj":"12345678910"}"

LIST (página 0, 10 por página):
curl "http://localhost:8080/api/v2/users?page=0&size=10&sort=username,ASC
"

GET BY ID:
curl "http://localhost:8080/api/v2/users/42
"

LIST CONSUMOS:
curl "http://localhost:8080/api/v2/users/42/consumos
"

CHANGE PASSWORD:
curl -X PATCH http://localhost:8080/api/v2/users/42/password

-H "Content-Type: application/json"
-d "{"oldPassword":"Senha@123","newPassword":"NovaSenha@456"}"

CHANGE USERNAME:
curl -X PATCH http://localhost:8080/api/v2/users/42/username

-H "Content-Type: application/json"
-d "{"username":"novoApelido"}"

DELETE BY ID:
curl -X DELETE "http://localhost:8080/api/v2/users/42
"

DELETE BY EMAIL:
curl -X DELETE "http://localhost:8080/api/v2/users/by-email/novo@exemplo.com
"

============================================================
BOAS PRÁTICAS NO FRONT

Normalize inputs onde fizer sentido:

E-mail: trim e lowercase antes de enviar.

Trate 422 VALIDATION_ERROR com feedback por campo (ex.: “email inválido”, “username obrigatório”).

Após criar, editar e deletar, invalide a lista (ex.: React Query: invalidateQueries).

Datas (dataConsumo) vêm como yyyy-MM-dd; formate na UI para pt-BR.

Em caso de CONSTRAINT_VIOLATION ou BAD_REQUEST “Username ja existente”, destaque o campo problemático e oriente correção.


============================== PRODUTOS ==============================
BASE
Base URL: /api/v2/products
Headers padrão: Content-Type: application/json
CORS: liberado para qualquer origem
Observação: Controller não requer autenticação por enquanto. Se o back adicionar, use Authorization: Bearer <token>.
============================================================
DTOS (FORMATOS DOS DADOS)
ProductRequestDTO:
name: string
type: string
description: string
ProductResponseDTO:
id: number
name: string
type: string
description: string
ApiError:
status: number        (ex.: 400, 404, 409)
error: string         (ex.: "Bad Request", "Not Found", "Conflict")
message: string       (detalhe do erro; virá do ResultService quando houver)
============================================================
ENDPOINTS E EXEMPLOS


CRIAR PRODUTO



POST /api/v2/products
Request (JSON):
{
"name": "Café Premium",
"type": "Bebida",
"description": "Café torrado e moído 500g"
}
Response 201 (Created) + Location: /api/v2/products/{id}
{
"id": 42,
"name": "Café Premium",
"type": "Bebida",
"description": "Café torrado e moído 500g"
}
Erros possíveis:


400 Bad Request (validação falhou no ResultService)


409 Conflict (já existe produto com mesmo nome, regra de negócio)




LISTAR TODOS



GET /api/v2/products
Response 200:
[
{ "id": 1, "name": "Café", "type": "Bebida", "description": "250g" },
{ "id": 2, "name": "Chá",  "type": "Bebida", "description": "Camomila" }
]


BUSCAR POR ID



GET /api/v2/products/{id}
Response 200:
{ "id": 42, "name": "...", "type": "...", "description": "..." }
Erro 404:
{ "status": 404, "error": "Not Found", "message": "Produto não encontrado" }


BUSCAR POR NOME (EXATO)



GET /api/v2/products/by-name/{name}
Response 200:
{ "id": 7, "name": "Café Premium", "type": "Bebida", "description": "..." }
Erro 404:
{ "status": 404, "error": "Not Found", "message": "Produto não encontrado" }


ATUALIZAR (PUT COMPLETO)



PUT /api/v2/products/{id}
Request (JSON):
{
"name": "Café Premium",
"type": "Bebida",
"description": "Atualizado: 500g embalagem a vácuo"
}
Response 200:
{ "id": 42, "name": "Café Premium", "type": "Bebida", "description": "Atualizado: 500g embalagem a vácuo" }
Erros possíveis:


404 Not Found (produto inexistente)


400 Bad Request (validação falhou)


409 Conflict (conflito de negócio)




DELETAR POR ID



DELETE /api/v2/products/{id}
Response 204 (sem corpo)
Erros possíveis:


400 Bad Request (quando ResultService considera inválido)


404 Not Found (produto não encontrado)




DELETAR POR NOME



DELETE /api/v2/products/by-name/{name}
Response 204 (sem corpo)
Erros possíveis:


400 Bad Request (quando ResultService considera inválido)


404 Not Found (produto não encontrado)


============================================================
PADRÕES DE ERRO (TRATAMENTO NO FRONT)
HTTP 400 – Bad Request


Quando: validação/regra de negócio falha (ResultService.isValid = false).


Ação: mostre ApiError.message próximo aos campos ou em um toast.


HTTP 404 – Not Found


Quando: produto não existe para GET/PUT/DELETE.


Ação: feedback “Produto não encontrado”.


HTTP 409 – Conflict


Quando: regra de negócio impede operação (ex.: duplicidade).


Ação: informe conflito (ex.: “Já existe produto com esse nome”).


============================================================
EXEMPLOS RÁPIDOS (FETCH/AXIOS)
Criar (fetch):
const res = await fetch("/api/v2/products", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({
name: "Café Premium",
type: "Bebida",
description: "Café 500g"
})
});
if (res.status === 201) {
const body = await res.json(); // ProductResponseDTO
// usar body.id, body.name...
} else {
const err = await res.json();  // ApiError
// exibir err.message
}
Atualizar (axios):
import axios from "axios";
await axios.put(/api/v2/products/${id}, {
name, type, description
}).then(r => {
// r.data: ProductResponseDTO atualizado
}).catch(async (e) => {
// e.response.data: ApiError
});
Deletar por nome (fetch):
const res = await fetch(/api/v2/products/by-name/${encodeURIComponent(name)}, {
method: "DELETE"
});
if (res.status === 204) {
// removido
} else {
const err = await res.json(); // ApiError
}
============================================================
CLIENT PRONTO (AXIOS) – SUGESTÃO
import axios from "axios";
const http = axios.create({
baseURL: "/api/v2/products",
headers: { "Content-Type": "application/json" }
});
export const ProductsApi = {
create: (body) =>
http.post("", body).then(r => r.data),
listAll: () =>
http.get("").then(r => r.data),
getById: (id) =>
http.get(/${id}).then(r => r.data),
getByName: (name) =>
http.get(/by-name/${encodeURIComponent(name)}).then(r => r.data),
update: (id, body) =>
http.put(/${id}, body).then(r => r.data),
deleteById: (id) =>
http.delete(/${id}).then(() => {}),
deleteByName: (name) =>
http.delete(/by-name/${encodeURIComponent(name)}).then(() => {})
};
============================================================
CURL PARA TESTES RÁPIDOS
CRIAR:
curl -X POST http://localhost:8080/api/v2/products
-H "Content-Type: application/json"
-d "{"name":"Café Premium","type":"Bebida","description":"Café 500g"}"
LISTAR:
curl http://localhost:8080/api/v2/products
BUSCAR POR ID:
curl http://localhost:8080/api/v2/products/42
BUSCAR POR NOME:
curl http://localhost:8080/api/v2/products/by-name/Caf%C3%A9%20Premium
ATUALIZAR:
curl -X PUT http://localhost:8080/api/v2/products/42
-H "Content-Type: application/json"
-d "{"name":"Café Premium","type":"Bebida","description":"Atualizado: 500g a vácuo"}"
DELETAR POR ID:
curl -X DELETE http://localhost:8080/api/v2/products/42
DELETAR POR NOME:
curl -X DELETE http://localhost:8080/api/v2/products/by-name/Caf%C3%A9%20Premium
============================================================
BOAS PRÁTICAS NO FRONT


Validar formulário antes do POST/PUT; mapear mensagens do ApiError.message.


Ao criar/atualizar/deletar, recarregar a listagem (ex.: invalidateQueries no React Query).


Normalizar strings conforme a regra de negócio (name/type/description com trim).


Em 409 (Conflict), destaque o campo que causou a duplicidade e proponha correção.


Em 404, redirecione para a lista e mostre aviso “Produto não encontrado”.



============================= PESQUISAS ===============================
BASE

Base URL: /api/v2/pesquisas
Headers padrão: Content-Type: application/json
CORS: liberado para qualquer origem
Observação: Controller não requer autenticação por enquanto.

============================================================
DTOS (FORMATOS DOS DADOS)

PesquisaRequestDTO (REQUEST):
consumoId: number (ID de Consumo existente)
nota: number (ex.: 0..10)
dataPesquisa: string (ISO yyyy-MM-dd)
tipoPesquisa: string (enum, ex.: "NPS", "CSAT", etc.)
resposta: string | null (texto livre opcional)

PesquisaResponseDTO (RESPONSE):
id: number
consumoId: number
nota: number
dataPesquisa: string (ISO yyyy-MM-dd)
tipoPesquisa: string (enum)
tipoCliente: string (enum; definido no back com base nas regras de negócio)
resposta: string | null

KpiResponseDTO (RESPONSE – KPIs):
media: number | null (média das notas no período)
distribuicao: array de objetos { tipoCliente: string, count: number }
(usa a projeção PesquisaRepository.TipoClienteCount)

ApiError / Mensagens de erro (quando houver):
Pode vir como lista de erros de validação (BindingResult) ou texto simples.
Para 400/409/404 este controller geralmente devolve strings com a mensagem.

Enums esperados:
TipoPesquisa: ex.: "NPS", "CSAT", "CES" (confirme com o back os valores)
TipoCliente: ex.: "PROMOTOR", "NEUTRO", "DETRATOR" (ou equivalente)

============================================================
ENDPOINTS E EXEMPLOS

CRIAR PESQUISA

POST /api/v2/pesquisas

Request (JSON):
{
"consumoId": 123,
"nota": 9,
"dataPesquisa": "2025-11-07",
"tipoPesquisa": "NPS",
"resposta": "Atendimento excelente."
}

Responses:
201 Created:
(PesquisaResponseDTO do registro criado)
400 Bad Request:

Lista de erros de validação (BindingResult)

"Consumo não encontrado: id={id}" se consumoId inválido
409 Conflict:

Lista de mensagens do ResultService quando regra de negócio conflitar

OBTER POR ID

GET /api/v2/pesquisas/{id}

Responses:
200 OK:
(PesquisaResponseDTO)
404 Not Found:
(sem corpo)

OBTER POR CONSUMO (UM-para-UM)

GET /api/v2/pesquisas/by-consumo/{consumoId}

Responses:
200 OK:
(PesquisaResponseDTO)
400 Bad Request:
"Consumo não encontrado: id={id}" (quando consumo não existe)
404 Not Found:
(quando não há pesquisa associada a esse consumo)

LISTAR / FILTRAR (PAGINADO)

GET /api/v2/pesquisas
Parâmetros (query):
tipoPesquisa (obrigatório): string (enum)
tipoCliente (opcional): string (enum)
inicio (opcional): yyyy-MM-dd
fim (opcional): yyyy-MM-dd
page (opcional, default 0): number
size (opcional, default 20): number
sort (opcional): ex.: sort=dataPesquisa,ASC

Regras de filtro:

Se tipoCliente e período (inicio & fim) forem informados:
filtra por tipoPesquisa + tipoCliente + dataPesquisa BETWEEN [inicio,fim]

Se só tipoCliente for informado:
filtra por tipoPesquisa + tipoCliente

Se só período (inicio & fim) for informado:
filtra por tipoPesquisa + período

Caso contrário:
filtra apenas por tipoPesquisa

Response 200:
Page<PesquisaResponseDTO> (objeto paginado padrão do Spring)
Campos úteis: content[], totalElements, totalPages, size, number, first, last, empty

Exemplos de URLs:
/api/v2/pesquisas?tipoPesquisa=NPS&page=0&size=20
/api/v2/pesquisas?tipoPesquisa=NPS&tipoCliente=PROMOTOR&page=0&size=10
/api/v2/pesquisas?tipoPesquisa=NPS&inicio=2025-01-01&fim=2025-12-31
/api/v2/pesquisas?tipoPesquisa=NPS&tipoCliente=DETRATOR&inicio=2025-01-01&fim=2025-12-31&sort=dataPesquisa,DESC

KPIs (MÉDIA E DISTRIBUIÇÃO)

GET /api/v2/pesquisas/kpis
Parâmetros (query):
tipoPesquisa (obrigatório): string (enum)
inicio (obrigatório): yyyy-MM-dd
fim (obrigatório): yyyy-MM-dd

Responses:
200 OK:
{
"media": 8.1,
"distribuicao": [
{ "tipoCliente": "PROMOTOR", "count": 120 },
{ "tipoCliente": "NEUTRO", "count": 35 },
{ "tipoCliente": "DETRATOR", "count": 12 }
]
}

ATUALIZAR PESQUISA (PUT)

PUT /api/v2/pesquisas/{id}

Request (JSON) – mesmos campos do create:
{
"consumoId": 123,
"nota": 7,
"dataPesquisa": "2025-11-07",
"tipoPesquisa": "NPS",
"resposta": "Demora no atendimento."
}

Responses:
200 OK:
(PesquisaResponseDTO atualizado)
400 Bad Request:

Lista de erros de validação (BindingResult)

"Consumo não encontrado: id={id}"
404 Not Found:

"Pesquisa para atualizar inexistente"

DELETAR PESQUISA

DELETE /api/v2/pesquisas/{id}

Responses:
204 No Content:
(exclusão bem-sucedida)
404 Not Found:

Lista de mensagens do ResultService (quando não encontrado/ inválido)

============================================================
EXEMPLOS RÁPIDOS (FETCH/AXIOS)
Criar (fetch):

const res = await fetch("/api/v2/pesquisas", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({
consumoId: 123,
nota: 9,
dataPesquisa: "2025-11-07",
tipoPesquisa: "NPS",
resposta: "Muito bom."
})
});
if (res.status === 201) {
const body = await res.json(); // PesquisaResponseDTO
} else {
const err = await res.json(); // lista de erros ou string
}

Listar (axios) com filtros e paginação:

import axios from "axios";

const { data } = await axios.get("/api/v2/pesquisas", {
params: {
tipoPesquisa: "NPS",
tipoCliente: "PROMOTOR", // opcional
inicio: "2025-01-01", // opcional (requer fim se usar período)
fim: "2025-12-31", // opcional (requer inicio)
page: 0,
size: 20,
sort: "dataPesquisa,DESC"
}
});
// data é um Page<PesquisaResponseDTO>

KPIs (fetch):

const url = "/api/v2/pesquisas/kpis?tipoPesquisa=NPS&inicio=2025-01-01&fim=2025-12-31";
const res = await fetch(url);
const kpis = await res.json(); // { media, distribuicao }

Atualizar (axios):

await axios.put(/api/v2/pesquisas/${id}, {
consumoId, nota, dataPesquisa, tipoPesquisa, resposta
});

Deletar (fetch):

const res = await fetch(/api/v2/pesquisas/${id}, { method: "DELETE" });
if (res.status !== 204) {
const err = await res.json();
}

============================================================
CLIENT PRONTO (AXIOS) – SUGESTÃO

import axios from "axios";

const http = axios.create({
baseURL: "/api/v2/pesquisas",
headers: { "Content-Type": "application/json" }
});

export const PesquisasApi = {
criar: (body) =>
http.post("", body).then(r => r.status === 201 ? r.data : Promise.reject(r.data)),

obterPorId: (id) =>
http.get(/${id}).then(r => r.data),

obterPorConsumo: (consumoId) =>
http.get(/by-consumo/${consumoId}).then(r => r.data),

listar: (params /* { tipoPesquisa, tipoCliente?, inicio?, fim?, page?, size?, sort? } */) =>
http.get("", { params }).then(r => r.data),

kpis: (params /* { tipoPesquisa, inicio, fim } */) =>
http.get("/kpis", { params }).then(r => r.data),

atualizar: (id, body) =>
http.put(/${id}, body).then(r => r.data),

deletar: (id) =>
http.delete(/${id}).then(() => {})
};

============================================================
CURL PARA TESTES RÁPIDOS

CRIAR:
curl -X POST http://localhost:8080/api/v2/pesquisas

-H "Content-Type: application/json"
-d "{"consumoId":123,"nota":9,"dataPesquisa":"2025-11-07","tipoPesquisa":"NPS","resposta":"Muito bom."}"

OBTER POR ID:
curl http://localhost:8080/api/v2/pesquisas/42

OBTER POR CONSUMO:
curl http://localhost:8080/api/v2/pesquisas/by-consumo/123

LISTAR (apenas tipoPesquisa):
curl "http://localhost:8080/api/v2/pesquisas?tipoPesquisa=NPS&page=0&size=20
"

LISTAR (tipoPesquisa + tipoCliente + período):
curl "http://localhost:8080/api/v2/pesquisas?tipoPesquisa=NPS&tipoCliente=PROMOTOR&inicio=2025-01-01&fim=2025-12-31&page=0&size=20&sort=dataPesquisa,DESC
"

KPIs:
curl "http://localhost:8080/api/v2/pesquisas/kpis?tipoPesquisa=NPS&inicio=2025-01-01&fim=2025-12-31
"

ATUALIZAR:
curl -X PUT http://localhost:8080/api/v2/pesquisas/42

-H "Content-Type: application/json"
-d "{"consumoId":123,"nota":7,"dataPesquisa":"2025-11-07","tipoPesquisa":"NPS","resposta":"Demora no atendimento."}"

DELETAR:
curl -X DELETE http://localhost:8080/api/v2/pesquisas/42

============================================================
BOAS PRÁTICAS NO FRONT

Sempre enviar dataPesquisa em formato ISO (yyyy-MM-dd).

Validar existência de consumoId no fluxo de UI (buscar/selecionar consumo antes).

Tratar 400/409/404 exibindo mensagem clara; para listas de erros (BindingResult), mapear para os campos do formulário.

Ao usar filtros de período, sempre enviar inicio e fim juntos.

Após criar/atualizar/deletar, recarregar as listas (invalidateQueries, refetch, etc.).


=============================== CONSUMO =============================
BASE
Base URL: /api/v2/consumos
Headers padrão: Content-Type: application/json
CORS: liberado para qualquer origem
Observação: Controller não requer autenticação por enquanto.
============================================================
DTOS (FORMATOS DOS DADOS)
ConsumoRequestDTO (REQUEST):
user:        objeto/identificador de usuário (ver contrato do back)
product:     objeto/identificador de produto (ver contrato do back)
consumiuPesquisa: boolean
pesquisa:    objeto/identificador de pesquisa OU null
dataConsumo: string (ISO yyyy-MM-dd)
ConsumoResponseDTO (RESPONSE):
id: number
userId: number | null
productId: number | null
dataConsumo: string (ISO yyyy-MM-dd)
pesquisaRespondida: boolean
pesquisaId: number | null
ApiError:
status: number        (ex.: 400, 404, 409)
error: string         (ex.: "Bad Request", "Not Found", "Conflict")
message: string       (detalhe do erro originado do ResultService)
============================================================
ENDPOINTS E REGRAS


CRIAR CONSUMO



POST /api/v2/consumos
Request (JSON):
{
"user": { ... },            // ou apenas o ID, conforme seu DTO real
"product": { ... },         // ou apenas o ID
"consumiuPesquisa": true,
"pesquisa": { ... } ,       // ou null
"dataConsumo": "2025-11-07"
}
Responses:
201 Created:
ConsumoResponseDTO
400 Bad Request:
ResultService inválido (mensagens no ApiError.message)
409 Conflict:
Regra de negócio conflitou (ex.: "Consumo ja existente")
Observação: após salvar, o controller retorna o consumo mais recente do usuário (findTopByUser_IdOrderByDataConsumoDesc).


LISTAR (PAGINADO + FILTROS)



GET /api/v2/consumos
Query params (todos opcionais):
page, size, sort              // paginação padrão Spring
userId: number
productId: number
inicio: yyyy-MM-dd
fim: yyyy-MM-dd
somenteComPesquisa: boolean   // true = só com pesquisa, false = só sem pesquisa
Regras de prioridade do filtro:


Se somenteComPesquisa != null:


true  -> findByPesquisaIsNotNull


false -> findByPesquisaIsNull




Se userId + (inicio & fim) informados:


findByUser_IdAndDataConsumoBetween




Se apenas userId:


findByUser_Id




Se apenas productId:


findByProduto_Id




Se apenas período (inicio & fim):


findByDataConsumoBetween




Sem filtros:


findAll




Response 200:
Page<ConsumoResponseDTO>
Exemplos de URLs:
/api/v2/consumos?page=0&size=10&sort=dataConsumo,DESC
/api/v2/consumos?somenteComPesquisa=true&page=0&size=20
/api/v2/consumos?userId=42&inicio=2025-01-01&fim=2025-12-31
/api/v2/consumos?productId=7
/api/v2/consumos?inicio=2025-10-01&fim=2025-10-31


BUSCAR POR ID



GET /api/v2/consumos/{id}
Responses:
200 OK:
ConsumoResponseDTO
404 Not Found:
{ "status": 404, "error": "Not Found", "message": "Consumo não encontrado" }


LISTAR POR USUÁRIO (SEM PAGINAÇÃO)



GET /api/v2/consumos/by-user/{userId}
Response 200:
ConsumoResponseDTO[]


ATUALIZAR (PUT)



PUT /api/v2/consumos/{id}
Request (JSON) – mesmos campos do create:
{
"user": { ... },
"product": { ... },
"consumiuPesquisa": false,
"pesquisa": null,
"dataConsumo": "2025-11-08"
}
Responses:
200 OK:
ConsumoResponseDTO (do consumo mais recente do usuário após a atualização)
400 Bad Request:
ResultService inválido
404 Not Found:
ResultService não realizou a operação (ex.: consumo não encontrado)
Observação importante:


O serviço de update, no estado atual, atualiza “pelo user” (regra específica do seu service) e não estritamente pelo ID.


O controller, por isso, retorna o “mais recente” do usuário após atualizar.


Recomenda-se alinhar a regra no back para atualizar “por ID” no futuro.




DELETAR



DELETE /api/v2/consumos/{id}
Responses:
204 No Content:
Exclusão bem-sucedida
400 Bad Request:
ResultService inválido
404 Not Found:
ResultService não realizou (não encontrado)
============================================================
EXEMPLOS RÁPIDOS (FETCH/AXIOS)
Criar (fetch):
const res = await fetch("/api/v2/consumos", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({
user: { id: 42 },               // adeque ao seu DTO real
product: { id: 7 },
consumiuPesquisa: true,
pesquisa: { id: 99 },           // ou null
dataConsumo: "2025-11-07"
})
});
if (res.status === 201) {
const body = await res.json(); // ConsumoResponseDTO
} else {
const err = await res.json();  // ApiError
}
Listar (axios) com filtros e paginação:
import axios from "axios";
const { data } = await axios.get("/api/v2/consumos", {
params: {
page: 0,
size: 10,
sort: "dataConsumo,DESC",
userId: 42,            // opcional
productId: 7,          // opcional
inicio: "2025-01-01",  // opcional (usar com fim)
fim: "2025-12-31",     // opcional (usar com inicio)
somenteComPesquisa: true // opcional
}
});
// data é Page<ConsumoResponseDTO>
Atualizar (axios):
await axios.put(/api/v2/consumos/${id}, {
user: { id: 42 },
product: { id: 7 },
consumiuPesquisa: false,
pesquisa: null,
dataConsumo: "2025-11-08"
}).then(r => {
// r.data: ConsumoResponseDTO (mais recente do usuário)
}).catch(e => {
// e.response.data: ApiError
});
Deletar (fetch):
const res = await fetch(/api/v2/consumos/${id}, { method: "DELETE" });
if (res.status !== 204) {
const err = await res.json(); // ApiError
}
============================================================
CLIENT PRONTO (AXIOS) – SUGESTÃO
import axios from "axios";
const http = axios.create({
baseURL: "/api/v2/consumos",
headers: { "Content-Type": "application/json" }
});
export const ConsumosApi = {
create: (body) =>
http.post("", body).then(r => r.data),
list: (params /* { page?, size?, sort?, userId?, productId?, inicio?, fim?, somenteComPesquisa? } */) =>
http.get("", { params }).then(r => r.data),
getById: (id) =>
http.get(/${id}).then(r => r.data),
listByUser: (userId) =>
http.get(/by-user/${userId}).then(r => r.data),
update: (id, body) =>
http.put(/${id}, body).then(r => r.data),
delete: (id) =>
http.delete(/${id}).then(() => {})
};
============================================================
CURL PARA TESTES RÁPIDOS
CRIAR:
curl -X POST http://localhost:8080/api/v2/consumos
-H "Content-Type: application/json"
-d "{"user":{"id":42},"product":{"id":7},"consumiuPesquisa":true,"pesquisa":{"id":99},"dataConsumo":"2025-11-07"}"
LISTAR (paginado, sem filtros):
curl "http://localhost:8080/api/v2/consumos?page=0&size=10&sort=dataConsumo,DESC"
LISTAR (somente com pesquisa):
curl "http://localhost:8080/api/v2/consumos?somenteComPesquisa=true&page=0&size=20"
LISTAR (por usuário + período):
curl "http://localhost:8080/api/v2/consumos?userId=42&inicio=2025-01-01&fim=2025-12-31"
BUSCAR POR ID:
curl "http://localhost:8080/api/v2/consumos/123"
LISTAR POR USUÁRIO (sem paginação):
curl "http://localhost:8080/api/v2/consumos/by-user/42"
ATUALIZAR:
curl -X PUT http://localhost:8080/api/v2/consumos/123
-H "Content-Type: application/json"
-d "{"user":{"id":42},"product":{"id":7},"consumiuPesquisa":false,"pesquisa":null,"dataConsumo":"2025-11-08"}"
DELETAR:
curl -X DELETE "http://localhost:8080/api/v2/consumos/123"
============================================================
BOAS PRÁTICAS NO FRONT


Sempre enviar dataConsumo em formato ISO (yyyy-MM-dd).


Definir claramente no front se os campos user/product/pesquisa serão enviados como objetos mínimos {id} ou como IDs simples; alinhar com o DTO real do back.


Em filtros de período, envie inicio e fim juntos.


Para somenteComPesquisa, lembre que tem prioridade sobre os outros filtros.


Após create/update/delete, refaça o fetch da listagem (invalidateQueries/refetch).

